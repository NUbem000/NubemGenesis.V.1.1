/**
 * Orchestration Observability for NubemGenesis
 * Integrates with LangSmith for tracing and Prometheus for metrics
 */

import { register, Counter, Histogram, Gauge, Summary } from 'prom-client'
import { OrchestrationRequest, OrchestrationResponse } from './MetaOrchestrator'
import axios from 'axios'

export interface TracingConfig {
    enabled: boolean
    langsmithApiKey?: string
    langsmithProjectName?: string
    langfusePublicKey?: string
    langfuseSecretKey?: string
    langfuseHost?: string
}

export interface MetricsConfig {
    enabled: boolean
    metricsPort?: number
    metricsPath?: string
}

export class OrchestrationObservability {
    private tracingConfig: TracingConfig
    private metricsConfig: MetricsConfig
    
    // Prometheus metrics
    private metrics: {
        orchestrationDuration: Histogram<string>
        orchestrationRequests: Counter<string>
        orchestrationErrors: Counter<string>
        modelSelections: Counter<string>
        flowGenerations: Counter<string>
        cacheHits: Counter<string>
        cacheMisses: Counter<string>
        activeOrchestrations: Gauge<string>
        evaluationScores: Summary<string>
        componentUsage: Counter<string>
    }

    constructor(tracingConfig?: Partial<TracingConfig>, metricsConfig?: Partial<MetricsConfig>) {
        this.tracingConfig = {
            enabled: tracingConfig?.enabled ?? true,
            langsmithApiKey: tracingConfig?.langsmithApiKey || process.env.LANGSMITH_API_KEY,
            langsmithProjectName: tracingConfig?.langsmithProjectName || 'nubemgenesis-orchestration',
            langfusePublicKey: tracingConfig?.langfusePublicKey || process.env.LANGFUSE_PUBLIC_KEY,
            langfuseSecretKey: tracingConfig?.langfuseSecretKey || process.env.LANGFUSE_SECRET_KEY,
            langfuseHost: tracingConfig?.langfuseHost || process.env.LANGFUSE_HOST || 'https://cloud.langfuse.com'
        }

        this.metricsConfig = {
            enabled: metricsConfig?.enabled ?? true,
            metricsPort: metricsConfig?.metricsPort || 9090,
            metricsPath: metricsConfig?.metricsPath || '/metrics'
        }

        // Initialize Prometheus metrics
        this.metrics = {
            orchestrationDuration: new Histogram({
                name: 'nubemgenesis_orchestration_duration_seconds',
                help: 'Duration of orchestration requests in seconds',
                labelNames: ['workflow_type', 'status', 'complexity'],
                buckets: [0.1, 0.5, 1, 2, 5, 10, 30]
            }),
            orchestrationRequests: new Counter({
                name: 'nubemgenesis_orchestration_requests_total',
                help: 'Total number of orchestration requests',
                labelNames: ['workflow_type', 'status']
            }),
            orchestrationErrors: new Counter({
                name: 'nubemgenesis_orchestration_errors_total',
                help: 'Total number of orchestration errors',
                labelNames: ['error_type', 'component']
            }),
            modelSelections: new Counter({
                name: 'nubemgenesis_model_selections_total',
                help: 'Total model selections by model and provider',
                labelNames: ['model', 'provider']
            }),
            flowGenerations: new Counter({
                name: 'nubemgenesis_flow_generations_total',
                help: 'Total flows generated by type',
                labelNames: ['flow_type', 'complexity']
            }),
            cacheHits: new Counter({
                name: 'nubemgenesis_cache_hits_total',
                help: 'Total cache hits',
                labelNames: ['cache_type']
            }),
            cacheMisses: new Counter({
                name: 'nubemgenesis_cache_misses_total',
                help: 'Total cache misses',
                labelNames: ['cache_type']
            }),
            activeOrchestrations: new Gauge({
                name: 'nubemgenesis_active_orchestrations',
                help: 'Number of active orchestrations',
                labelNames: ['workflow_type']
            }),
            evaluationScores: new Summary({
                name: 'nubemgenesis_evaluation_scores',
                help: 'Model evaluation scores',
                labelNames: ['model', 'category'],
                percentiles: [0.5, 0.9, 0.95, 0.99]
            }),
            componentUsage: new Counter({
                name: 'nubemgenesis_component_usage_total',
                help: 'Component usage by category and name',
                labelNames: ['category', 'component']
            })
        }

        // Register all metrics
        if (this.metricsConfig.enabled) {
            Object.values(this.metrics).forEach(metric => register.registerMetric(metric))
        }
    }

    /**
     * Trace an orchestration request
     */
    async traceOrchestration(
        request: OrchestrationRequest,
        handler: () => Promise<OrchestrationResponse>
    ): Promise<OrchestrationResponse> {
        const startTime = Date.now()
        const timer = this.metrics.orchestrationDuration.startTimer()
        
        // Start active orchestration gauge
        this.metrics.activeOrchestrations.inc({ workflow_type: 'unknown' })

        try {
            // Create trace span
            const traceId = this.generateTraceId()
            const span = await this.startTrace(traceId, 'orchestration', {
                request,
                timestamp: new Date().toISOString()
            })

            // Execute handler
            const response = await handler()

            // Update metrics
            const labels = {
                workflow_type: response.flow.type || 'unknown',
                status: 'success',
                complexity: this.getComplexity(response)
            }
            
            timer(labels)
            this.metrics.orchestrationRequests.inc(labels)

            // Track model selections
            response.metadata.modelsSelected.forEach(model => {
                this.metrics.modelSelections.inc({
                    model,
                    provider: this.getProvider(model)
                })
            })

            // Track flow generation
            this.metrics.flowGenerations.inc({
                flow_type: response.flow.type,
                complexity: labels.complexity
            })

            // Track component usage
            response.metadata.componentsUsed.forEach(componentId => {
                const [category, component] = componentId.split('/')
                this.metrics.componentUsage.inc({ category, component })
            })

            // End trace span
            await this.endTrace(span, {
                response: {
                    flowId: response.flowId,
                    confidence: response.confidence,
                    estimatedCost: response.estimatedCost,
                    estimatedLatency: response.estimatedLatency
                },
                duration: Date.now() - startTime
            })

            return response

        } catch (error) {
            // Update error metrics
            timer({ workflow_type: 'unknown', status: 'error', complexity: 'unknown' })
            this.metrics.orchestrationErrors.inc({
                error_type: error.name || 'unknown',
                component: 'orchestrator'
            })

            // Log error to tracing
            await this.logError(error, { request, duration: Date.now() - startTime })

            throw error

        } finally {
            // Decrease active orchestrations
            this.metrics.activeOrchestrations.dec({ workflow_type: 'unknown' })
        }
    }

    /**
     * Track cache performance
     */
    trackCacheHit(cacheType: string = 'orchestration'): void {
        this.metrics.cacheHits.inc({ cache_type: cacheType })
    }

    trackCacheMiss(cacheType: string = 'orchestration'): void {
        this.metrics.cacheMisses.inc({ cache_type: cacheType })
    }

    /**
     * Track evaluation scores
     */
    trackEvaluationScore(model: string, category: string, score: number): void {
        this.metrics.evaluationScores.observe({ model, category }, score)
    }

    /**
     * Start a trace span
     */
    private async startTrace(traceId: string, operation: string, metadata: any): Promise<any> {
        if (!this.tracingConfig.enabled) return null

        // LangSmith integration
        if (this.tracingConfig.langsmithApiKey) {
            try {
                const response = await axios.post(
                    'https://api.smith.langchain.com/runs',
                    {
                        id: traceId,
                        name: operation,
                        run_type: 'chain',
                        start_time: new Date().toISOString(),
                        inputs: metadata,
                        project_name: this.tracingConfig.langsmithProjectName,
                        tags: ['orchestration', 'nubemgenesis']
                    },
                    {
                        headers: {
                            'x-api-key': this.tracingConfig.langsmithApiKey,
                            'Content-Type': 'application/json'
                        }
                    }
                )
                return { traceId, provider: 'langsmith', runId: response.data.id }
            } catch (error) {
                console.error('Failed to start LangSmith trace:', error)
            }
        }

        // Langfuse integration
        if (this.tracingConfig.langfusePublicKey && this.tracingConfig.langfuseSecretKey) {
            try {
                const auth = Buffer.from(
                    `${this.tracingConfig.langfusePublicKey}:${this.tracingConfig.langfuseSecretKey}`
                ).toString('base64')

                const response = await axios.post(
                    `${this.tracingConfig.langfuseHost}/api/public/traces`,
                    {
                        id: traceId,
                        name: operation,
                        metadata,
                        timestamp: new Date().toISOString()
                    },
                    {
                        headers: {
                            'Authorization': `Basic ${auth}`,
                            'Content-Type': 'application/json'
                        }
                    }
                )
                return { traceId, provider: 'langfuse', data: response.data }
            } catch (error) {
                console.error('Failed to start Langfuse trace:', error)
            }
        }

        return null
    }

    /**
     * End a trace span
     */
    private async endTrace(span: any, outputs: any): Promise<void> {
        if (!span || !this.tracingConfig.enabled) return

        if (span.provider === 'langsmith' && this.tracingConfig.langsmithApiKey) {
            try {
                await axios.patch(
                    `https://api.smith.langchain.com/runs/${span.runId}`,
                    {
                        end_time: new Date().toISOString(),
                        outputs,
                        status: 'success'
                    },
                    {
                        headers: {
                            'x-api-key': this.tracingConfig.langsmithApiKey,
                            'Content-Type': 'application/json'
                        }
                    }
                )
            } catch (error) {
                console.error('Failed to end LangSmith trace:', error)
            }
        }

        if (span.provider === 'langfuse') {
            try {
                const auth = Buffer.from(
                    `${this.tracingConfig.langfusePublicKey}:${this.tracingConfig.langfuseSecretKey}`
                ).toString('base64')

                await axios.post(
                    `${this.tracingConfig.langfuseHost}/api/public/spans`,
                    {
                        traceId: span.traceId,
                        name: 'orchestration-complete',
                        startTime: new Date(Date.now() - outputs.duration).toISOString(),
                        endTime: new Date().toISOString(),
                        metadata: outputs
                    },
                    {
                        headers: {
                            'Authorization': `Basic ${auth}`,
                            'Content-Type': 'application/json'
                        }
                    }
                )
            } catch (error) {
                console.error('Failed to end Langfuse trace:', error)
            }
        }
    }

    /**
     * Log error to tracing
     */
    private async logError(error: Error, context: any): Promise<void> {
        if (!this.tracingConfig.enabled) return

        const errorData = {
            error: {
                name: error.name,
                message: error.message,
                stack: error.stack
            },
            context,
            timestamp: new Date().toISOString()
        }

        // Log to LangSmith
        if (this.tracingConfig.langsmithApiKey) {
            try {
                await axios.post(
                    'https://api.smith.langchain.com/runs',
                    {
                        name: 'orchestration-error',
                        run_type: 'chain',
                        start_time: new Date().toISOString(),
                        end_time: new Date().toISOString(),
                        inputs: context,
                        outputs: errorData,
                        status: 'error',
                        project_name: this.tracingConfig.langsmithProjectName,
                        tags: ['error', 'orchestration']
                    },
                    {
                        headers: {
                            'x-api-key': this.tracingConfig.langsmithApiKey
                        }
                    }
                )
            } catch (err) {
                console.error('Failed to log error to LangSmith:', err)
            }
        }
    }

    /**
     * Get Prometheus metrics
     */
    async getMetrics(): Promise<string> {
        return register.metrics()
    }

    /**
     * Get metrics in JSON format
     */
    async getMetricsJSON(): Promise<any> {
        return register.getMetricsAsJSON()
    }

    /**
     * Helper methods
     */
    private generateTraceId(): string {
        return `trace_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    }

    private getComplexity(response: OrchestrationResponse): string {
        const nodeCount = response.metadata.componentsUsed.length
        if (nodeCount <= 3) return 'low'
        if (nodeCount <= 7) return 'medium'
        return 'high'
    }

    private getProvider(model: string): string {
        if (model.includes('gpt')) return 'openai'
        if (model.includes('claude')) return 'anthropic'
        if (model.includes('gemini')) return 'google'
        if (model.includes('mistral')) return 'mistral'
        if (model.includes('llama') || model.includes('mixtral')) return 'together'
        return 'unknown'
    }

    /**
     * Start metrics server
     */
    async startMetricsServer(app: any): Promise<void> {
        if (!this.metricsConfig.enabled) return

        app.get(this.metricsConfig.metricsPath, async (req: any, res: any) => {
            try {
                res.set('Content-Type', register.contentType)
                const metrics = await this.getMetrics()
                res.end(metrics)
            } catch (error) {
                res.status(500).end(error)
            }
        })

        console.log(`ðŸ“Š Prometheus metrics available at ${this.metricsConfig.metricsPath}`)
    }
}

// Export singleton instance
export const orchestrationObservability = new OrchestrationObservability()